(function(window, document, undefined) {
  // using http://paulirish.com/2011/requestanimationframe-for-smart-animating/
  // shim layer with setTimeout fallback
  window.requestAnimFrame = (function() {
    return  window.requestAnimationFrame || 
    window.webkitRequestAnimationFrame   || 
    window.mozRequestAnimationFrame      || 
    window.oRequestAnimationFrame        || 
    window.msRequestAnimationFrame       || 
    function(callback) { window.setTimeout(callback, 1000 / 60); }
  })();

  window.Leap = {
    ready: []
  }

  var exports = window.Leap

	<%= load_file("./websocketjs/swfobject.js") %>
	<%= load_file("./websocketjs/web_socket.js") %>
	<%= load_file("./lib/*.js") %>

	for (var readyIdx in Leap.ready) {
		Leap.ready[readyIdx](new Leap.Controller())
	}
})(this, document);

//WEB_SOCKET_SWF_LOCATION = "websocketjs/WebSocketMain.swf";
//
//window.leap = {
//	settings: {
//		flushTimeout: 500,			// time until a hand gets deleted from history, after disappearing
//		memory: 60,					// # of frames kept in history for each hand
//		sampleRate: 1,				// how often frames get saved to history
//		refreshTimeout: 1000,		// wait time to try and reconnect if server fails
//		refreshTries: 10,			// # of times client will try to reconnect
//		refreshCounter: 0,			
//		debug: false,				// if true, will print every JSON object received and keep hands in history
//	},		
//	currentFrame: {},			// latest fram received
//	hands: {},					// stores all hands currently in view
//	fingers: {},				// data structure to easily access fingers
//	events: {}, 				// "event": [boolean, state] function(handID, data) returns boolean
//	handlers: {
//		'enter': function(handID, data){}, 
//		'exit': function(handID, data){},
//		'frame': function(handID, data) {
//			return data;
//		},
//		'ready': function(handID, data) {}
//	}, 							// "event": function(handID, data)
//	
//	event: function(eventName, eventFunc) {				// leap.event(name, function) creates new event
//		this.events[eventName] = eventFunc;
//	},
//	on: function(eventName, handlerFunc) {				// leap.on(name, function) assigns handler to event
//		this.handlers[eventName] = handlerFunc;
//	},
//	hand: function(handID, index) {						// leap.hand(handID, index) gets a hand "index" frames ago
//		if (index != undefined) {
//			var history = this.hands[handID].history;
//			return history[(history.length-index-1) % history.length];
//		}
//		else {
//			return this.hands[handID].latest;
//		}
//	},
//	finger: function(fingerID, index) {					// leap.finger(fingerID, index) gets a finger "index" frames ago
//		var fingerRef = this.fingers[fingerID];
//		try {
//			var fingerObj = this.hand(fingerRef.parent, index).fingers[fingerRef.index];
//			fingerObj.parent = fingerRef.parent;
//			return fingerObj;
//		}
//		catch(e) {
//			console.log("finger", fingerID, "no longer exists");
//		}
//	},
//	palm: function(handID, index) {						// leap.palm(handID, index) gets a palm "index" frames ago
//		return this.hand(handID, index).palm;
//	},
//	fire: function(eventName, handID, data) {			// leap.fire(name, handID, data) manually fires an event
//		this.handlers[eventName](handID, data);
//	},
//	config: function(setNew) {
//		for (var setting in this.settings) {
//			if (setNew[setting] != undefined) {
//				this.settings[setting] = setNew[setting];
//			}
//		}
//	},
//}
//
//// Travel back in time and kill yourself
//function looper(handID, past) {
//	if (leap.hands.hasOwnProperty(handID)) {
//		var now = leap.hand(handID).time;
//		if (now == past) {
//			leap.fire('exit', handID, [past, now] );
//			delete leap.hands[handID];
//		}
//		else {
//			setTimeout(function() {
//				looper(handID, now);
//			}, leap.settings.flushTimeout);
//		}
//	}
//}
//
//function onopen(message) {
//	console.log("connected to leap");
//	leap.socket.send("hello");
//	leap.fire("ready");
//	leap.settings.refreshCounter = 0;
//};
//
//function onmessage(message) {
//	currentFrame = JSON.parse(message.data);
//	leap.currentFrame = currentFrame;
//	leap.fire('frame', undefined, currentFrame);
//	
//	if (leap.settings.debug) {
//		console.log(currentFrame);
//	}
//	
//	for (var i=0; i<currentFrame.hands.length; i++) {
//		var hand = currentFrame.hands[i],
//			handID = hand.id;
//	
//		var latest = {
//			time: currentFrame.timestamp / 1000,
//			frameID: currentFrame.id,
//			fingers: hand.fingers,
//			palm: hand.palm,
//		};
//		
//		if (leap.hands.hasOwnProperty(handID)) {
//			leap.hands[handID].latest = latest;
//			if (currentFrame.id % leap.settings.sampleRate == 0) {
//				leap.hands[handID].history.push(latest);
//			}
//			if (leap.hands[handID].history.length > leap.settings.memory) {
//				leap.hands[handID].history.shift();
//			}
//		}
//		else {
//			leap.hands[handID] = {
//				latest: latest,
//				history: [latest],
//			};
//			leap.fire('enter', handID, latest);
//			if (!leap.settings.debug) {
//				setTimeout(function() {
//					looper(handID, latest.time)
//				}, leap.settings.flushTimeout);
//			}
//		}
//		
//		for (var j=0; j<hand.fingers.length; j++) {
//			leap.fingers[hand.fingers[j].id] = {
//				parent: handID,
//				index: j,
//			};
//		}
//		
//		for (var eventName in leap.events) {
//			if (leap.handlers.hasOwnProperty(eventName)) {
//				var result = leap.events[eventName](handID);
//				if (result.ready) {
//					leap.fire(eventName, handID, result.data);
//				}
//			}
//		}
//	}
//};
//
//function onclose() {
//	if (leap.settings.refreshCounter < leap.settings.refreshTries) {
//		leap.settings.refreshCounter++;
//		setTimeout(start, leap.settings.refreshTimeout);
//	}
//	else {
//		console.log("leap disconnected");
//	}
//};
//
//function start() {
//	console.log("connecting...");
//	leap.socket = new WebSocket("ws://localhost:6437");
//	leap.socket.onopen = onopen;
//	leap.socket.onmessage = onmessage;
//	leap.socket.onclose = onclose;
//
//	var controller = new Leap.Controller();
//	controller.onFrame(function(frame) {
//
//	});
//};